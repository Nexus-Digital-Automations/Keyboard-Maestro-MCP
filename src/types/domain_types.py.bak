# src/types/domain_types.py
"""
Core domain types for the Keyboard Maestro MCP Server.

This module defines the primary domain types that model the core business
entities and their relationships using type-driven development principles.
"""

from typing import Optional, FrozenSet, Dict, Any, Union, List
from dataclasses import dataclass
from datetime import datetime
from enum import Enum

from .identifiers import (
    MacroUUID, MacroName, GroupUUID, VariableName, 
    ExecutionID, MacroIdentifier, VariableIdentifier
)
from .values import (
    MacroExecutionTimeout, VariableValue, ScreenCoordinates,
    ConfidenceScore, FilePath
)
from .enumerations import (
    MacroState, VariableScope, TriggerType, ActionType,
    ExecutionStatus, ErrorType, ExecutionMethod,
    ConnectionStatus, PoolStatus, ResourceType, AlertLevel,
    PluginScriptType, PluginOutputHandling, PluginLifecycleState, PluginSecurityLevel
)


# Core Domain Entity Types
@dataclass(frozen=True)
class MacroMetadata:
    """Immutable macro metadata with core properties."""
    uuid: MacroUUID
    name: MacroName
    group_id: Optional[GroupUUID]
    state: MacroState
    created_at: datetime
    modified_at: datetime
    notes: Optional[str] = None
    
    def is_executable(self) -> bool:
        """Check if macro can be executed."""
        return self.state.can_execute()
    
    def is_modifiable(self) -> bool:
        """Check if macro can be modified."""
        return self.state.can_modify()


@dataclass(frozen=True)
class TriggerConfiguration:
    """Immutable trigger configuration."""
    trigger_type: TriggerType
    parameters: Dict[str, Any]
    enabled: bool = True
    
    def __post_init__(self):
        """Validate trigger configuration."""
        if not self.parameters:
            raise ValueError("Trigger parameters cannot be empty")
        
        # Validate required parameters based on trigger type
        required_params = self._get_required_parameters()
        missing_params = required_params - set(self.parameters.keys())
        if missing_params:
            raise ValueError(f"Missing required parameters: {missing_params}")
    
    def _get_required_parameters(self) -> FrozenSet[str]:
        """Get required parameters for trigger type."""
        param_map = {
            TriggerType.HOTKEY: frozenset(['key', 'modifiers']),
            TriggerType.APPLICATION: frozenset(['application']),
            TriggerType.TIME: frozenset(['schedule']),
            TriggerType.FILE_FOLDER: frozenset(['path', 'event']),
            TriggerType.SYSTEM: frozenset(['event_type']),
            TriggerType.DEVICE: frozenset(['device_type']),
            TriggerType.NETWORK: frozenset(['endpoint']),
            TriggerType.CLIPBOARD: frozenset(['content_type'])
        }
        return param_map.get(self.trigger_type, frozenset())
    
    def _make_hashable(self, obj):
        """Convert potentially unhashable objects to hashable ones."""
        if isinstance(obj, dict):
            return tuple(sorted((k, self._make_hashable(v)) for k, v in obj.items()))
        elif isinstance(obj, list):
            return tuple(self._make_hashable(item) for item in obj)
        elif isinstance(obj, set):
            return frozenset(self._make_hashable(item) for item in obj)
        else:
            return obj
    
    def __hash__(self) -> int:
        """Make trigger configuration hashable for use in sets."""
        return hash((
            self.trigger_type, 
            self._make_hashable(self.parameters), 
            self.enabled
        ))


@dataclass(frozen=True)
class ActionConfiguration:
    """Immutable action configuration."""
    action_type: ActionType
    parameters: Dict[str, Any]
    enabled: bool = True
    
    def __post_init__(self):
        """Validate action configuration."""
        if not self.parameters:
            raise ValueError("Action parameters cannot be empty")
    
    def _make_hashable(self, obj):
        """Convert potentially unhashable objects to hashable ones."""
        if isinstance(obj, dict):
            return tuple(sorted((k, self._make_hashable(v)) for k, v in obj.items()))
        elif isinstance(obj, list):
            return tuple(self._make_hashable(item) for item in obj)
        elif isinstance(obj, set):
            return frozenset(self._make_hashable(item) for item in obj)
        else:
            return obj
    
    def __hash__(self) -> int:
        """Make action configuration hashable for use in sets."""
        return hash((
            self.action_type,
            self._make_hashable(self.parameters),
            self.enabled
        ))


@dataclass(frozen=True)
class MacroDefinition:
    """Complete immutable macro definition."""
    metadata: MacroMetadata
    triggers: FrozenSet[TriggerConfiguration]
    actions: FrozenSet[ActionConfiguration]
    
    def __post_init__(self):
        """Validate macro definition."""
        if not self.triggers and not self.actions:
            raise ValueError("Macro must have at least one trigger or action")
    
    @property
    def trigger_count(self) -> int:
        """Get number of configured triggers."""
        return len(self.triggers)
    
    @property
    def action_count(self) -> int:
        """Get number of configured actions."""
        return len(self.actions)
    
    def has_trigger_type(self, trigger_type: TriggerType) -> bool:
        """Check if macro has trigger of specified type."""
        return any(trigger.trigger_type == trigger_type for trigger in self.triggers)
    
    def has_action_type(self, action_type: ActionType) -> bool:
        """Check if macro has action of specified type."""
        return any(action.action_type == action_type for action in self.actions)


@dataclass(frozen=True)
class VariableDefinition:
    """Immutable variable definition with metadata."""
    identifier: VariableIdentifier
    value: Optional[VariableValue]
    created_at: datetime
    modified_at: datetime
    
    @property
    def exists(self) -> bool:
        """Check if variable has a value."""
        return self.value is not None
    
    def is_password_variable(self) -> bool:
        """Check if variable is password type."""
        return self.identifier.is_password()


@dataclass(frozen=True)
class ExecutionContext:
    """Immutable execution context for operations."""
    execution_id: ExecutionID
    macro_id: MacroUUID
    method: ExecutionMethod
    trigger_value: Optional[str]
    timeout: MacroExecutionTimeout
    start_time: datetime
    status: ExecutionStatus
    
    def is_terminal(self) -> bool:
        """Check if execution is in terminal state."""
        return self.status.is_terminal_state()
    
    def is_active(self) -> bool:
        """Check if execution is actively running."""
        return self.status.is_active_state()
    
    def can_be_cancelled(self) -> bool:
        """Check if execution can be cancelled."""
        return self.status.can_be_cancelled()


@dataclass(frozen=True)
class OperationError:
    """Comprehensive error information."""
    error_type: ErrorType
    message: str
    details: Optional[str] = None
    recovery_suggestion: Optional[str] = None
    error_code: Optional[str] = None
    
    def is_recoverable(self) -> bool:
        """Check if error is potentially recoverable."""
        return self.error_type.is_recoverable()
    
    def requires_user_action(self) -> bool:
        """Check if error requires user intervention."""
        return self.error_type.requires_user_action()


@dataclass(frozen=True)
class ContextInfo:
    """MCP context information for session tracking."""
    context_id: str
    session_id: str
    created_at: float
    last_activity: float = 0.0
    current_progress: int = 0
    total_progress: int = 0
    request_count: int = 0
    
    def __post_init__(self):
        """Initialize mutable fields if not set."""
        if self.last_activity == 0.0:
            object.__setattr__(self, 'last_activity', self.created_at)
    
    @property
    def age_seconds(self) -> float:
        """Get context age in seconds."""
        import time
        return time.time() - self.created_at
    
    @property
    def idle_seconds(self) -> float:
        """Get idle time in seconds."""
        import time
        return time.time() - self.last_activity


@dataclass(frozen=True)
class OCRTextExtraction:
    """Individual OCR text extraction with metadata."""
    text: str
    confidence: ConfidenceScore
    bounding_box: ScreenCoordinates
    language: str
    
    def __post_init__(self):
        """Validate extraction data."""
        if not self.text:
            raise ValueError("Extracted text cannot be empty")
        if not self.language:
            raise ValueError("Language must be specified")
    
    def is_high_confidence(self) -> bool:
        """Check if extraction has high confidence."""
        return self.confidence >= 0.8
    
    def __hash__(self) -> int:
        """Make text extraction hashable."""
        return hash((self.text, self.confidence, self.language))


@dataclass(frozen=True)
class MacroCreationData:
    """Data structure for creating new macros."""
    name: str
    group_uuid: Optional[str] = None
    enabled: bool = True
    color: Optional[str] = None
    notes: Optional[str] = None
    triggers: Optional[List[Dict[str, Any]]] = None
    actions: Optional[List[Dict[str, Any]]] = None
    
    def __post_init__(self):
        """Validate creation data."""
        if not self.name or not self.name.strip():
            raise ValueError("Macro name cannot be empty")


@dataclass(frozen=True)
class MacroModificationData:
    """Data structure for modifying existing macros."""
    name: Optional[str] = None
    group_uuid: Optional[str] = None
    enabled: Optional[bool] = None
    color: Optional[str] = None
    notes: Optional[str] = None
    triggers: Optional[List[Dict[str, Any]]] = None
    actions: Optional[List[Dict[str, Any]]] = None
    
    def has_changes(self) -> bool:
        """Check if any modification data is provided."""
        return any([
            self.name is not None,
            self.group_uuid is not None,
            self.enabled is not None,
            self.color is not None,
            self.notes is not None,
            self.triggers is not None,
            self.actions is not None
        ])


@dataclass(frozen=True)
class PerformanceThreshold:
    """Performance monitoring thresholds configuration."""
    resource_type: ResourceType
    warning_threshold: float
    critical_threshold: float
    alert_level: AlertLevel = AlertLevel.WARNING
    
    def __post_init__(self):
        """Validate threshold configuration."""
        if self.critical_threshold <= self.warning_threshold:
            raise ValueError("Critical threshold must be greater than warning threshold")
        if self.warning_threshold < 0 or self.critical_threshold > 100:
            raise ValueError("Thresholds must be between 0 and 100")
    
    def is_exceeded(self, current_value: float) -> bool:
        """Check if current value exceeds thresholds."""
        return current_value >= self.warning_threshold
    
    def is_critical(self, current_value: float) -> bool:
        """Check if current value exceeds critical threshold."""
        return current_value >= self.critical_threshold


@dataclass(frozen=True)
class MacroExecutionContext:
    """Context for macro execution with validation."""
    identifier: Union[MacroUUID, MacroName]
    trigger_value: Optional[str] = None
    method: ExecutionMethod = ExecutionMethod.APPLESCRIPT
    timeout: int = 30
    context_variables: Optional[Dict[str, str]] = None
    
    def __post_init__(self):
        """Validate execution context parameters."""
        if self.timeout <= 0 or self.timeout > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        if isinstance(self.identifier, str) and len(self.identifier.strip()) == 0:
            raise ValueError("Macro identifier cannot be empty")


# Additional Enums needed by other modules
class SessionStatus(Enum):
    """Status of MCP session."""
    ACTIVE = "active"
    INACTIVE = "inactive"
    TERMINATED = "terminated"


class SerializationFormat(Enum):
    """Supported serialization formats."""
    JSON = "json"
    XML = "xml"
    PLIST = "plist"
    KMMACROS = "kmmacros"
    KMLIBRARY = "kmlibrary"


class ToolStatus(Enum):
    """Status of a tool in the MCP server."""
    ENABLED = "enabled"
    DISABLED = "disabled"
    DEPRECATED = "deprecated"
    EXPERIMENTAL = "experimental"


@dataclass(frozen=True)
class ServiceStatus:
    """Status of a communication service."""
    available: bool
    service_name: str
    last_check: Optional[str] = None
    error_message: Optional[str] = None


@dataclass(frozen=True)
class AudioDevice:
    """Audio device information for macOS."""
    name: str
    is_default: bool = False
    
    def __post_init__(self):
        """Validate audio device."""
        if not self.name or not self.name.strip():
            raise ValueError("Device name cannot be empty")
    
    def __hash__(self) -> int:
        """Make audio device hashable."""
        return hash((self.name, self.is_default))


@dataclass(frozen=True)
class MacroExecutionResult:
    """Result of macro execution operation."""
    success: bool
    execution_id: Optional[str] = None
    result_data: Optional[Dict[str, Any]] = None
    error_message: Optional[str] = None
    execution_time: Optional[float] = None
    
    def __post_init__(self):
        """Validate execution result."""
        if self.success and self.error_message:
            raise ValueError("Successful result cannot have error message")
        if not self.success and not self.error_message:
            raise ValueError("Failed result must have error message")


# Plugin Domain Types

@dataclass(frozen=True)
class PluginParameter:
    """Configuration for a single parameter in a custom plugin action."""
    name: str  # The variable name (e.g., KMPARAM_Your_Param_Name)
    label: str
    default_value: str = ""
    parameter_type: str = "text"
    is_required: bool = False
    
    def __post_init__(self):
        """Validate plugin parameter configuration."""
        if not self.name or not self.name.strip():
            raise ValueError("Parameter name cannot be empty")
        if not self.label or not self.label.strip():
            raise ValueError("Parameter label cannot be empty")
        
        # Validate parameter name format (Keyboard Maestro convention)
        if not self.name.startswith("KMPARAM_"):
            raise ValueError("Parameter name must start with 'KMPARAM_'")
        
        # Check for valid identifier characters
        import re
        param_suffix = self.name[8:]  # Remove 'KMPARAM_' prefix
        if not re.match(r'^[A-Za-z_][A-Za-z0-9_]*
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, param_suffix):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }


# Factory Functions for Safe Construction
def create_macro_metadata(
    uuid: MacroUUID,
    name: MacroName,
    group_id: Optional[GroupUUID] = None,
    state: MacroState = MacroState.DISABLED,
    notes: Optional[str] = None
) -> MacroMetadata:
    """Create macro metadata with safe defaults.
    
    Args:
        uuid: Macro UUID
        name: Macro name
        group_id: Optional group UUID
        state: Initial state
        notes: Optional notes
        
    Returns:
        MacroMetadata: Validated metadata object
    """
    now = datetime.now()
    return MacroMetadata(
        uuid=uuid,
        name=name,
        group_id=group_id,
        state=state,
        created_at=now,
        modified_at=now,
        notes=notes
    )


def create_execution_context(
    execution_id: ExecutionID,
    macro_id: MacroUUID,
    method: ExecutionMethod,
    timeout: MacroExecutionTimeout,
    trigger_value: Optional[str] = None
) -> ExecutionContext:
    """Create execution context with safe defaults.
    
    Args:
        execution_id: Unique execution identifier
        macro_id: Target macro UUID
        method: Execution method
        timeout: Execution timeout
        trigger_value: Optional trigger value
        
    Returns:
        ExecutionContext: Validated execution context
    """
    return ExecutionContext(
        execution_id=execution_id,
        macro_id=macro_id,
        method=method,
        trigger_value=trigger_value,
        timeout=timeout,
        start_time=datetime.now(),
        status=ExecutionStatus.PENDING
    )


def create_plugin_metadata(
    plugin_id: str,
    action_name: str,
    script_type: PluginScriptType,
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED,
    description: Optional[str] = None
) -> PluginMetadata:
    """Create plugin metadata with safe defaults.
    
    Args:
        plugin_id: Unique plugin identifier
        action_name: Human-readable action name
        script_type: Type of script
        security_level: Security classification
        description: Optional description
        
    Returns:
        PluginMetadata: Validated plugin metadata
    """
    now = datetime.now()
    return PluginMetadata(
        plugin_id=plugin_id,
        action_name=action_name,
        script_type=script_type,
        state=PluginLifecycleState.CREATED,
        security_level=security_level,
        created_at=now,
        modified_at=now,
        description=description
    )


def create_plugin_parameter(
    name: str,
    label: str,
    default_value: str = "",
    parameter_type: str = "text",
    is_required: bool = False
) -> PluginParameter:
    """Create plugin parameter with validation.
    
    Args:
        name: Parameter variable name (must start with KMPARAM_)
        label: Human-readable label
        default_value: Default value
        parameter_type: Parameter type
        is_required: Whether parameter is required
        
    Returns:
        PluginParameter: Validated parameter
    """
    return PluginParameter(
        name=name,
        label=label,
        default_value=default_value,
        parameter_type=parameter_type,
        is_required=is_required
    )


def create_plugin_execution_context(
    plugin_id: str,
    execution_id: str,
    parameters: Dict[str, str],
    timeout_seconds: int = 30,
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
) -> PluginExecutionContext:
    """Create plugin execution context with security defaults.
    
    Args:
        plugin_id: Plugin identifier
        execution_id: Unique execution ID
        parameters: Execution parameters
        timeout_seconds: Execution timeout
        security_level: Security level for resource limits
        
    Returns:
        PluginExecutionContext: Validated execution context
    """
    # Set resource limits based on security level
    max_memory = 50 if security_level == PluginSecurityLevel.SANDBOXED else 100
    allow_network = security_level.can_access_network()
    
    return PluginExecutionContext(
        plugin_id=plugin_id,
        execution_id=execution_id,
        parameters=parameters,
        timeout_seconds=timeout_seconds,
        max_memory_mb=max_memory,
        allow_network_access=allow_network
    )
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
, self.name):
, self.name):
            raise ValueError("Parameter name must be valid identifier format")
    
    def get_variable_name(self) -> str:
        """Get the Keyboard Maestro variable name for this parameter."""
        return self.name
    
    def __hash__(self) -> int:
        """Make parameter hashable for use in sets."""
        return hash((self.name, self.label, self.default_value, self.parameter_type, self.is_required))


@dataclass(frozen=True)
class PluginCreationData:
    """Complete data structure for creating a new plugin action."""
    action_name: str
    script_type: PluginScriptType
    script_content: str
    parameters: Optional[List[PluginParameter]] = None
    output_handling: PluginOutputHandling = PluginOutputHandling.IGNORE
    output_variable: Optional[str] = None  # For SAVE_TO_VARIABLE
    security_level: PluginSecurityLevel = PluginSecurityLevel.SANDBOXED
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate plugin creation data."""
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        if len(self.action_name) > 100:
            raise ValueError("Action name cannot exceed 100 characters")
        
        if not self.script_content or not self.script_content.strip():
            raise ValueError("Script content cannot be empty")
        
        # Validate output variable requirement
        if (self.output_handling == PluginOutputHandling.SAVE_TO_VARIABLE and 
            not self.output_variable):
            raise ValueError("Output variable name required for SAVE_TO_VARIABLE handling")
        
        # Validate parameters if provided
        if self.parameters:
            param_names = [param.name for param in self.parameters]
            if len(param_names) != len(set(param_names)):
                raise ValueError("Parameter names must be unique")
    
    @property
    def parameter_count(self) -> int:
        """Get number of configured parameters."""
        return len(self.parameters) if self.parameters else 0
    
    @property
    def bundle_name(self) -> str:
        """Get the bundle name for this plugin."""
        # Clean action name for filesystem use
        import re
        clean_name = re.sub(r'[^a-zA-Z0-9_\-\s]', '', self.action_name)
        clean_name = re.sub(r'\s+', ' ', clean_name).strip()
        return f"{clean_name}.kmsync"
    
    def requires_network_access(self) -> bool:
        """Check if plugin may require network access based on script type."""
        # Conservative approach - assume shell and unrestricted plugins may need network
        return (self.script_type in (PluginScriptType.SHELL, PluginScriptType.PYTHON) or
                self.security_level.can_access_network())
    
    def is_high_risk(self) -> bool:
        """Check if plugin is classified as high risk."""
        return (self.security_level.get_risk_level() >= 2 or
                self.script_type.requires_system_access())


@dataclass(frozen=True)
class PluginMetadata:
    """Immutable plugin metadata with lifecycle information."""
    plugin_id: str
    action_name: str
    script_type: PluginScriptType
    state: PluginLifecycleState
    security_level: PluginSecurityLevel
    created_at: datetime
    modified_at: datetime
    bundle_path: Optional[str] = None
    description: Optional[str] = None
    version: str = "1.0.0"
    
    def __post_init__(self):
        """Validate plugin metadata."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        if not self.action_name or not self.action_name.strip():
            raise ValueError("Action name cannot be empty")
        
        # Validate version format
        import re
        if not re.match(r'^\d+\.\d+\.\d+
, self.version):
            raise ValueError("Version must be in semantic version format (x.y.z)")
    
    def is_operational(self) -> bool:
        """Check if plugin is operational."""
        return self.state.is_operational()
    
    def can_be_activated(self) -> bool:
        """Check if plugin can be activated."""
        return self.state.can_be_activated()
    
    def can_be_removed(self) -> bool:
        """Check if plugin can be removed."""
        return self.state.can_be_removed()
    
    def get_bundle_identifier(self) -> str:
        """Get the bundle identifier for this plugin."""
        # Clean plugin ID for bundle identifier
        import re
        clean_id = re.sub(r'[^a-zA-Z0-9_\-]', '', self.plugin_id)
        return f"com.mcp.generated.{clean_id}"


@dataclass(frozen=True)
class PluginValidationResult:
    """Result of plugin validation with security analysis."""
    is_valid: bool
    security_issues: List[str]
    warnings: List[str]
    required_permissions: List[str]
    estimated_risk_level: int  # 0-3 scale
    validation_errors: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate result structure."""
        if self.estimated_risk_level < 0 or self.estimated_risk_level > 3:
            raise ValueError("Risk level must be between 0 and 3")
        
        if not self.is_valid and not self.validation_errors:
            raise ValueError("Invalid plugin must have validation errors")
    
    def is_safe_for_auto_approval(self) -> bool:
        """Check if plugin is safe for automatic approval."""
        return (self.is_valid and 
                len(self.security_issues) == 0 and 
                self.estimated_risk_level <= 1)
    
    def requires_manual_review(self) -> bool:
        """Check if plugin requires manual security review."""
        return (len(self.security_issues) > 0 or 
                self.estimated_risk_level >= 2)


@dataclass(frozen=True)
class PluginInstallationResult:
    """Result of plugin installation operation."""
    success: bool
    plugin_id: str
    installation_path: Optional[str] = None
    error_message: Optional[str] = None
    warnings: Optional[List[str]] = None
    rollback_available: bool = False
    
    def __post_init__(self):
        """Validate installation result."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if self.success and self.error_message:
            raise ValueError("Successful installation cannot have error message")
        
        if not self.success and not self.error_message:
            raise ValueError("Failed installation must have error message")
        
        if self.success and not self.installation_path:
            raise ValueError("Successful installation must have installation path")
    
    def has_warnings(self) -> bool:
        """Check if installation has warnings."""
        return bool(self.warnings and len(self.warnings) > 0)


@dataclass(frozen=True)
class PluginExecutionContext:
    """Context for plugin execution with security constraints."""
    plugin_id: str
    execution_id: str
    parameters: Dict[str, str]
    timeout_seconds: int = 30
    max_memory_mb: int = 100
    allow_network_access: bool = False
    allowed_file_paths: Optional[List[str]] = None
    
    def __post_init__(self):
        """Validate execution context."""
        if not self.plugin_id or not self.plugin_id.strip():
            raise ValueError("Plugin ID cannot be empty")
        
        if not self.execution_id or not self.execution_id.strip():
            raise ValueError("Execution ID cannot be empty")
        
        if self.timeout_seconds <= 0 or self.timeout_seconds > 300:
            raise ValueError("Timeout must be between 1 and 300 seconds")
        
        if self.max_memory_mb <= 0 or self.max_memory_mb > 1000:
            raise ValueError("Memory limit must be between 1 and 1000 MB")
    
    def is_parameter_allowed(self, param_name: str) -> bool:
        """Check if parameter is in the allowed set."""
        return param_name in self.parameters
    
    def get_resource_limits(self) -> Dict[str, Any]:
        """Get resource limits for execution."""
        return {
            "timeout_seconds": self.timeout_seconds,
            "max_memory_mb": self.max_memory_mb,
            "allow_network": self.allow_network_access,
            "allowed_paths": self.allowed_file_paths or []
        }
